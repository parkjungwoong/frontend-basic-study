# 블록킹(동기), 논블록킹(비동기) 연산
동기와 비동기의 주요 구분점이라 함은 대기시간 또는 지연시간(latency)이다.

동기 연산: 실행 후 결과에 대한 응답이 올 때까지 대기 후 다음 연산이 진행되는 것

비동기 연산: 실행 후 결과에 대한 응답을 기다리지 않고 다음 연산이 진행되는 것

## 논블록킹 개념이 생겨난 배경
블록킹 코드를 작성하면 코드의 흐름을 하나의 스냡샷으로 파악할 수 있어서 코드 파악과 디버깅이 더 쉽다는 장점이 있지만 I/O 작업과 같이 연산에 대한 결과 반환에 latency가 길 경우 전체 어플리케이션의 처리 시간이 길어짐과 시스템 자원의 유휴시간이 길어서 자원을 효율적으로 활용할 수가 없다.

이러한 단점을 극복하기 위해 논블록킹 연산을 통해 해결할 수 있다. 그렇다면 논블록킹 연산을 코드상으로 어떻게 구현할 것인가는 다양한 방법이 있지만 가장 기본적으로 `CallBack function` 기법으 많이 사용한다.

## Callback function
Callback function 은 Nonblocking 연산의 결과를 함수로 받아 처리하겠다 라는 개념으로 예를 들어 네트워크 I/O를 요청하는 NonBlocking 연산을 수행하는 상황에서 네트워크 I/O결과를 Callback functiond의 파라미터 로 받아 callback function을 수행하겠다 라는 컨셉으로 쓰인다.

다만 Callback function은 Side effect를 발생시킬수 있는 함수이다. 왜냐하면 호출 시점이 다른 코드와 동기적으로 이루워지는게 아니기 때문에 만약 전역 변수를 callback function에서 사용할 경우 호출 순서에 따라 버그가 발생 할 수 있다. 이러한 특성 때문에 callback function은 `pure function`로 작성되어야한다.

### pure function
pure function의 코드 블록 외 다른 외부 변수를 참조하지 않는 함수, pure function내 연산 결과가 외부에 영향이 없어야한다.

## NonBlocking 연산의 잠재적 문제점
- 친숙한 흐름제어문(for, while, if...)이 논블록킹을 인식하지 못함
- 콜백의 중첩 문제로 인해 코드의 흐름, 에러처리, 재시도 로직의 복잡성이 증가한다.