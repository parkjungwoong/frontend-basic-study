# 3.핵심연산자

## 3.1 스트림의 평가와 취소
RxJS에서 데이터 스트림을 어떤 관점에서 바라보고 접근해야되는지, 스트림의 할당과 해지 방법에 대한 내용

### 스트림의 평가
여기서 *평가* 라는 단어를 책에서 사용했는데 RxJS에서 스트림을 보는 *관점* 정도로 생각하고 책을 읽으면 좋을거 같다.

- RxJS에서 스트림은 전적으로 프로그래머에 의해 정의되는 객체.

- 스트림의 수명이 옵저버블의 생성에서 시작하는것이 아닌 구독할때 시작한다.
    - 필요할 때 (구독할때) 데이터를 생성하는 lazy data source라는 용어로 사용할 수 있다.

- RxJS에서 lazy data source 방식을 유지하는 방법은 2가지 이다.
    1. 구독할때만 데이터를 생성
    2. 데이터를 메모리에 정적으로 보유하지 않고 이벤트가 방출되는 즉시 데이터를 전달

### 취소
여기서 취소는 옵저버블이 더이상 데이터를 push 하지 않도록 스트림을 해제하는 것

- 명시적으로 스트림을 취소하는 방법
    - `unsubscribe()`메소드 호출, 이 메소드는 `subscribe()`의 리턴값(Subscription 타입)에서 호출 할 수 있다.
    
- unsubscribe() 메소드는 옵저버블 객체를 해지하는 것이지, Promies, 등과 같이 취소 불가한 객체는 해지 되지 않는다.

- 연산자를 사용하면 대부분 구독 취소 작업을 자동으로 수행한다. 직접적으로 구독 취소를 할 경우는 거의 없다.

## 3.2 RxJS 옵저버블 연산자
연산자는 옵저버블의 파이프 라인안에서 동작할 로직을 삽입할 수 있는 함수

연산자는 순수함수이자 고차함수이다.즉 (*순수함수*)옵저버블을 변경시키지 않고, (*고차함수*)리턴값으로 새로운 옵저버블 객체를 반환한다.

### 핵심 연산자 소개
책에서는 연산자의 종류 2가지를 인스턴스 메서드, 옵저버블 타입이라고 소개했다. 

하지만 RxJS6 공식 문서에서는 `Pipeable Operators`, `Creation Operators` 이라고 소개하고 있어

인스턴스 메서드 = `Pipeable Operators`, 옵저버블 타입 = `Creation Operators` 이라고 생각하면 좋을거 같다.

또한 점 표기법으로 대신 RxJS6에서는 .pipe(연산자) 방식으로 연결한다.

- 이벤트 필터링: filter
- 결과 누적: reduce
- 결과 누적 스캐닝: scan
    - scan은 reduce와 기능적으론 같지만 scan은 누적 계산 결과를 바로 push 한다. reduce는 모아서 push, scan은 바로 push

## 3.3 집계 기능이 있는 연산자의 파이프라인 순서 지정
책에서 *집계 기능이 있는 연산자의* 이 말을 왜 붙였는지는 정확하게 이해가 안가지만 연산자들을 함수 체이닝(.pipe로 연결)하였을 때 내부적으로 어떻게 동작하는지,

그리고 각 연산자의 컨텍스트가 독립적이어야 된다는 점을 강조하는거 같다.

### 독립적인 파이프라인과 참조 투명성
옵저버블의 파이프라인은 독립적이여야한다. 즉 파이프라인의 동작으로 인해 외부 환경에 side effect가 없어야 한다.

다시 말하면 파이프라인은 파이프라인 밖의 데이터에 접근하지도 변경하지도 말아야한다. 그래야 옵저버블이 항상 동일한 값을 넣으면 동일한 결과 값을 반환할 수 있기 때문이다.

### RxJS 시퀀스의 성능 이점
책에서는 객체의 생성과 데이터 처리 두가지 관점으로 나눠서 설명하고 있다.

- 옵저버블의 생성 비용이 저렴하다.
    - 배열과 같은 경우는 생성시 지정 길이만큼 무조건 생성해야된다. 비록 이 배열이 바로 사용되는 상황이 아니더라도
    - 옵저버블은 데이터를 사용(구독)할 때 생성한다. 미리 객체를 생성하더라도 필요할때 데이터를 생성
    
- 중간 데이터를 생성하지 않는다.
    - 배열의 filter 메소드를 사용하면 원본 데이터의 결과에서 다시 새로운 배열을 반환하여 넘긴다.
    - 옵저버블의 경우 filter가 조건에 맞는 데이터를 바로 push한다. 중간에 새로운 데이터를 필요로 하지 않는다.
