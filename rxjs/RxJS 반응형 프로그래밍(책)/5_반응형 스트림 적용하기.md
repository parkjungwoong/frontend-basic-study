# 5.반응형 스트림 적용하기
이 장에서는 둘 이상의 스트림을 결합하여 하나의 스트림으로 처리하는 방법에 대해 알아본다.

필요한 데이터를 단일 소스로 운반하는 다른 옵저버블에 매핑하는 방식을 설명하는데 이를 FP에서는 데이터 타입의 평탄화라고 한다.

## 5.1 하나를 위한 모두, 모두를 위한 하나
다중 스트림을 병합하는 방법은 3가지가 있다.
1. 인터리빙: 들어온 스트림을 깔대기 처럼 한 곳으로 모아 보냄 (merge 연산자)
2. 순서 유지: 여러 스트림에서 들어오는 데이터의 순서를 유지 (concat 연산자)
3. 최신 데이터로 전환: 한 가지 유형의 이벤트가 다른 이벤트를 실행 (switchAll 연산자)

## 스트림을 병합하여 이벤트 인터리빙하기
merge연산자를 사용하면 다중 스트림을 결합할 수 있다. 
- 이 연산자는 이벤트를 도착한 순서대로 하나의 옵저버블로 전달한다.
- 병합된 스트림에서 다음 시퀀스에 있는 옵저버블이 데이터를 잘 처리 할 수 있도록 병합된 데이터가 하나의 데이터 타입으로 합쳐질 수 있도록 merge연산전에 적합한 데이터로 변환 해줘야한다.
- 병합된 옵저버블에서는 메모리에 있는 모든 데이터를 방출한다.
    - 비동기: 비동기 데이터의 경우 이벤트를 수신할때마다 방출
    - 동기: 모든 데이터를 한번에 방출, (배열 두개를 merge하면 병합된 배열을 한번에 방출함)
    
## 스트림을 연결하여 이벤트 순서 유지하기
두개의 스트림중 우선순위를 두어 첫번째 스트림이 모두 끝난 경우 다음 스트림을 방출하도록 하는 경우 merge 보단 concat연산자를 사용한다.

이 책에서는 두 스트림을 연결한다는 의미에서 연결이라는 단어를 사용했다. 하지만 주의해서 생각할 점은 두 스트림의 처음과 끝을 그대로 연결하는것이 아닌 이전 스트림의 완료 시점이 다음 스트림의 시작 시점이라는 점이다. 즉 이전 스트림이 발생하는 동안 이후 스트림의 데이터는 무시된다는 뜻이다.

- merge연산자의 경우 병합된 옵저버블을 통해 모든 소스 옵저버블을 동시에 구독할 수 있지만, concat연산자의 경우 한번에 하나의 소스 옵저버블만 구독 가능하다.
- concat연산자를 통해 첫번째 옵저버블의 스트림을 받는 동안 발생된 두번째 스트림의 내용은 모두 무시된다.

## 최신 옵저버블 데이터로 전환하기
switchAll로 체이닝된 소스 옵저버블에서 가장 최신 옵저버블을 제외한 나머지 옵저버블의 구독을 취소한다.
- 매핑된 최신 옵저버블에서 이벤틀르 방출한다.

## 5.2 중첩 옵저버블 처리하기
여기서 말하는 중첩 옵저버블은 리턴값이 소스 옵저버블을 반환하는 경우를 말한다. 즉 Observable<Observable<string>> 이런식이다.

- 병합: merge 대신 mergeMap
- 연결: concat 대신 concatMap
- 전환: switch 대신 swtichMap