# 함수
javaScript에서 함수에 관련된 내용

## 목차
- [함수의 기본 프로퍼티](#함수의 기본 프로퍼티)
- [함수에서 this](#함수에서-this)
- [화살표 함수](#화살표-함수)
- [call, apply, bind](#call-apply-bind)
- [참고링크](#참고링크)

## 함수의 기본 프로퍼티
1. arguments

## 함수에서 this
실행 컨텍스트에 따라 다르게 동작한다. 즉 호출의 주체가 누구냐에 따라 `this` 가 가르키는 대상이 달라짐, 단 화살표 표현식에서는 예외가 있다.

1. 객체의 메소드 호출: 실행 컨텍스트는 메소드를 호출한 객체가 된다.

``` javascript
const sayObj = {
    meg : 'hi',
    say : function (name) {
        //여기서 this.meg 는 메소드를 호출한 객체 자신, 즉 'hi'
        console.log(`${this.meg} ${name}!`);
    }
};

sayObj.say('pjw'); //hi pjw!
```

2. 함수를 호출: 실행 컨텍스트는 전역 객체, window와 같은 객체

``` javascript
window.globalMsg='hi';//브라우저에서는 window가 전역 객체이다. 전역 객체에 globalMsg 변수 추가

const say = function() { console.log(this.globalMsg)};
say();//hi
```

3. 생성자 함수를 호출: 실행 컨텍스트는 새로 생성되는 객체

``` javascript
function sayObj(meg) {
    this.meg = meg;
    this.say = function () {
        console.log(this.meg);
    }
}

const hello = new sayObj('hello');
hello.say(); //hello;
```

## 화살표 함수
화살표 함수는 `function` 으로 생성한 함수와 다른 특성을 갖고 있다.

1. this를 갖고 있지 않다.
2. 인수(arguments)를 갖고 있지 않다.
3. new 키워드로 호출할 수 없다.

화살표 함수의 이러한 특성은 자신의 컨텍스트를 갖고 있지 않기 때문이다. 화살표 함수는 *현재 수행중인 컨텍스트에서 짧은 코드를 위해 사용하기 위함* 목적에 맞게 동작하기 위해 이러한 특성을 갖고 있는것 같다.

### this를 갖고 있지 않다.
함수에서 `this`는 실행 주체에 따라 달라진다고 하였다. 하지만 화살표 함수는 `this`에 어떠한 값도 바인딩 하지 않는다.

이러한 개념을 갖고 아래 함수 내에서 `this.title` 를 보면 forEach가 함수를 호출하고 있으므로 여기서의 `this`는 forEach를 가르키고 있어야하는게 맞다. 하지만 실제로는 showList 메소드를 호출한 객체를 가르키고 있다.

``` javascript
let group = {
    title: "Our Group",
    students: ["John", "Pete", "Alice"],

    showList() {
        this.students.forEach(
            (student) => {
                console.log(`${this.title} : ${student}`)
                //여기서의 this는 showList메소드를 호출한 객체를 가르킨다.
            }
        );
    }
};

group.showList(); //Our Group: John ..Pete .. Alice 순차 출력
```
단 위 내용을 화살표 함수 표현식이 아닌 function으로 변경하였을 경우 실행 주체에 따라 달리진다는 개념으로 동작한다. 즉 `this`가 호출 주체인 forEach를 가르킨다.

``` javascript
let group = {
    title: "Our Group",
    students: ["John", "Pete", "Alice"],

    showList() {
        this.students.forEach(
            function (student) {
                console.log(`${this.title} : ${student}`);
                //여기서의 this는 forEach를 가르킨다.
            }
        );
    }
};

group.showList();// undefined : John ..Pete .. Alice 순차 출력
```

### 인수(arguments)를 갖고 있지 않다.
함수내에서 인수에 접근할때 `arguments` 라는 이름으로 가져올 수 있다.

화살표 함수는 자신의 `arguments` 가 없기 때문에 데코레이션 패턴의 코드에서 더 적은 코드를 작성할 수 있게 도와준다.

`function`의 경우

``` javascript
function defer(f, ms) {
    return function(...args) {
        let ctx = this;
        setTimeout(function() {
            //여기서 this로 접근시 setTimeout를 가르키므로 this를 별도 변수로 할당하여 전달
            //변수 또한 arguments로 접근시 setTimeout가 실행시키는 함수의 인수이므로 별도 변수로 전달
            return f.apply(ctx, ...args);
        }, ms);
    };
}
```

`화살표 함수`의 경우

``` javascript
function defer(f, ms) {
    return function() {
        setTimeout(() => {
            f.apply(this, arguments)
            //화살표 함수의 arguments는 자신이 아닌 반환되는 함수를 가르킴
        }, ms)
    };
}
```
### new 키워드로 호출할 수 없다.
화실표 함수는 prototype 객체와 생성자 함수가 없기 때문에 생성자를 통한 호출이 불가능하다.

``` javascript
const Foo = () => {};

// 화살표 함수는 prototype 프로퍼티가 없다
console.log(Foo.hasOwnProperty('prototype')); // false

const foo = new Foo(); // TypeError: Foo is not a constructor
```

## call, apply, bind
함수를 실행하는 방법중 하나로서 아래와 같이 사용한다.

매개변수값중 null 다음 `용도`에서 설명

``` javascript
const sum = (a,b) => a+b;

//모두 3출력
console.log(sum(1,2)) // 함수명(매개변수)
console.log(sum.call(null,1,2))// 함수명.call()
console.log(sum.apply(null,[1,2]))// 함수명.apply, call메소드와 달리 apply에서는 매개변수가 배열로 전달해야된다.
```

### 용도
실행할 함수에서 this로 바인딩 되는 값의 변경이 필요할 경우 사용한다.

``` javascript
const hi = {
    meg: 'hi',
    say: function(name) {
        console.log(`${this.meg} ${name}!`);
    }
};

hi.say('pjw'); //hi pjw!
hi.say.call({meg:'hello'}, 'pjw'); // hello pjw!
hi.say.apply({meg:'hello2'}, ['pjw']); // hello2 pjw!
const sayHello3 = hi.say.bind({meg:'hello3'});// bind는 함수를 실행시키지 않고 this만 변경한다.
sayHello3('pjw'); //hello3 pjw!
```

## 참고링크
- [화살표 함수](https://poiemaweb.com/es6-arrow-function)