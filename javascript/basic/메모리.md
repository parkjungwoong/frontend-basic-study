# 메모리
javaScript에서 메모리 구조, 관리에 대한 내용

## 목차
- [메모리 구조](#메모리-구조)
- [가비지 컬렉션](#가비지-컬렉션)
- []()
- [참고링크](#참고링크)

## 메모리 구조

### 실행 컨텍스트

### 스코프

## 가비지 컬렉션
[V8](https://v8.dev/)과 같은 자바스크립트 엔진은 `도달 가능성`에 따라 메모리 관리를 수행한다.

`도달 가능성`이라는 것은 선언된 변수에 대해 어떠한 방식으로든 접근이 가능한지 불가한지에 대한 가능성이다.

``` javascript
let obj = { name: 'pjw'};//메모리 어딘가에 객체가 생성되었고, obj변수에 참조에 대한 주소값이 저장되었다.

obj = null;//객체에 접근할 수 있는 주소값이 null로 덮어 씌워져 더이상 객체에 접근할 방법이 없다.
//이러한 경우 가비지 컬렉터는 해당 객체의 도달가능성이 없다 라고 판단하여 메모리에서 삭제한다.
```

### 내부 알고리즘
`mark-and-sweep` 알고리즘으로 동작한다.

1. root정보를 수집하고 mark함
2. root가 참조하고 있는 객체를 방문하며 mark함
3. 방문한 객체가 참조하고 있는 객체를 방문하며 mark함
4. mark 된 객체를 제외하고 도달 가능한 모든 객체를 탐색하여 mark함
5. mark 되지 않은 객체를 메모리에서 삭제

### 최적화 기법
- generational collection(세대별 수집)

    객체를 '새로운 객체'와 '오래된 객체'로 나눕니다. 객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 '새로운 객체'로 구분합니다. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거합니다. 일정 시간 이상 동안 살아남은 객체는 '오래된 객체'로 분류하고, 가비지 컬렉터가 덜 감시합니다.

- incremental collection(점진적 수집)
    방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모됩니다. 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려지겠죠. 자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다. 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있습니다.
- idle-time collection(유휴 시간 수집)
    가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.
    
*위 내용들은 자바스크립트 엔진마다 내용이 다르다.*
    
## 참고링크
- []()